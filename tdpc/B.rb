# Generated by AtcoderGreedy on 2018-04-22
# TDPC B
# Your code here

class Dp
  def initialize(record_addresses: true)
    @table = {}
    @addresses = {} if record_addresses
  end

  def []=(address, value)
    key = address_to_key address
    table[key] = value
  end

  def [](address)
    key = address_to_key address
    table[key]
  end

  def view
    table.map do |k, v|
      [@addresses[k], v]
    end.to_h
  end

  private

  def address_to_key(address)
    key = address.respond_to?(:intern) ? address.intern : address
    @addresses[key] ||= address if @addresses
    key
  end

  attr_reader :table
end

Address = Struct.new(:a, :b) do
  def intern
    (B + 1) * a + b
  end

  def to_s
    "(#{a},#{b})"
  end
end

def Address(a, b)
  Address.new(a, b)
end

def input_stdin
  large_a, large_b = gets.chomp.split(' ').map(&:to_i)
  a = gets.chomp.split(' ').map(&:to_i)
  b = gets.chomp.split(' ').map(&:to_i)
  [large_a, large_b, a, b]
end

INPUT_EXAMPLES = [
  [1, 2,
   [1],
   [2, 10]],
  [5, 5,
   [2, 4, 5, 4, 2],
   [2, 8, 3, 4, 5]]
]

def get_inputs
  if ENV['DEBUG']
    require 'pry'
    require 'pry-byebug'
    INPUT_EXAMPLES[ENV['DEBUG'].to_i]
  else
    input_stdin
  end
end

A, B, a, b = get_inputs

dp = Dp.new

binding.pry if binding.respond_to? :pry

dp[Address(-1, -1)] = [0, 0]

(0...A).each do |i|
  reward, counter = dp[Address(i - 1, -1)]
  dp[Address(i, -1)] = [a[i] + counter, reward]
end

(0...B).each do |i|
  reward, counter = dp[Address.new(-1, i - 1)]
  dp[Address(-1, i)] = [b[i] + counter, reward]
end

(0...A).each do |i|
  (0...B).each do |j|
    cand1 =
      begin
        reward, counter = dp[Address(i-1, j)]
        [a[i] + counter, reward]
      end
    cand2 =
      begin
        reward, counter = dp[Address(i, j-1)]
        [b[j] + counter, reward]
      end
    max = [cand1, cand2].max_by { |a, b| a - b }
    dp[Address(i, j)] = max
  end
end

puts dp[Address(A - 1, B - 1)][0]
