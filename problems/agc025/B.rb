#!/usr/bin/env ruby

# Generated by AtcoderGreedy on 2018-06-03
# AGC025 B

# my lib

module Enumerable
  # work just like String#split,
  # except this method does not use regex match
  # but check whether yield succeeds or not.
  def split
    current = nil
    ret = []
    each do |elem|
      if yield elem
        if current
          ret << current
          current = nil
        end
      elsif current
        current << elem
      else
        current = [elem]
      end
    end
    ret << current if current
    ret
  end
end

class Array
  # truncate tail, opposite of drop
  def clip(amount = 1)
    if amount < 0
      raise ArgumentError, "amount == #{amount}, cannot be negative!"
    end
    take_amount = size - amount
    take_amount < 0 ? [] : take(take_amount)
  end
end

# end of lib

# Your code here

MOD = 998244353

class ModularCalc
  def initialize(p)
    @p = p
  end

  attr_reader :p

  def n_choose_k(n, k)
    return 0 unless (0..n).cover? k
    return 1 if n == k || k == 0

    over = multiply(n - k + 1..n)
    under = multiply(1..k)

    under_inv = power(under, p - 2)
    (over * under_inv) % p
  end

  def multiply(enumerable)
    ret = 1
    enumerable.each do |i|
      ret *= i
      ret = ret % p
    end
    ret
  end

  def power(a, k)
    res = 1
    cur = a

    while k > 0
      if k % 2 != 0
        res = (res * cur) % p
      end
      k /= 2
      cur = (cur * cur) % p
    end
    res
  end

  class Combination
    def initialize(n, p)
      @modular_calc = ModularCalc.new p
      @n = n
      @p = p

      facts = Array.new(n + 1)
      facts[1] = 1
      (2..n).each do |i|
        facts[i] = (facts[i - 1] * i) % p
      end
      @facts = facts

      invs = Array.new(n + 1)
      facts.drop(1).each.with_index(1) do |fact, i|
        # $stderr.puts "#{i}: #{fact}"
        invs[i] = @modular_calc.power fact, p - 2
      end
      @invs = invs
    end

    def n_choose_k(n, k)
      return 0 unless n >= k && k >= 0
      return 1 if k.zero?
      args = [facts[n], invs[k], invs[n - k]]
      if args.any?(&:nil?)
        $stderr.puts({ n: n, k: k }.inspect)
        $stderr.puts invs.inspect
        $stderr.puts args.inspect
        raise 'hoge'
      end
      @modular_calc
        .multiply(args)
    end

    private

    attr_reader :facts, :invs
  end
end

N, A, B, K = gets.chomp.split(' ').map(&:to_i)

# $stderr.puts [N, A, B, K].inspect

class Calc
  def n_choose_k(n, k)
    @comb_calculator ||= ModularCalc::Combination.new N, MOD
    @comb_calculator.n_choose_k(n, k)
  end

  def a0
    @a0 ||=
      begin
        a = 0
        while a * A <= K
          return a if ((K - a * A) % B).zero?
          a += 1
        end
      end
  end

  def gcd
    @gcd ||=
      begin
        A.gcd(B)
      end
  end

  def main
    a = a0
    ret = 0
    while a * A <= K
      b = (K - a * A) / B
      raise 'hoge' unless ((K - a * A) % B).zero?

      n_c_a = n_choose_k(N, a)
      n_c_b = n_choose_k(N, b)
      # $stderr.puts "(a=#{a}, b=#{b}): nCa=#{n_c_a}, nCb=#{n_c_b}"

      comb = n_c_a * n_c_b
      comb = comb % MOD
      ret += comb
      ret = ret % MOD

      a += B / gcd
    end
    ret
  end
end

puts Calc.new.main
